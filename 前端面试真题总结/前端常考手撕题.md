### 手写防抖

```javascript
function debounce(fn,delay=100){
    let timer = null;
    return function(){
        if(timer){
            clearTimeout(timer);
        }
        timer = setTimeout(()=>{
            fn.apply(this,arguments);
            timer = null;
        },delay)
    }
}
input.addEventListener('keyup',debounce(function(){
    console.log(input.value);
},100))
```

### 手写节流

```javascript
function throttle(fn,delay = 100){
    let timer = null;
    return function(){
        if(timer){
            return ;
        }
        timer = setTimeout(()=>{
            fn.apply(this,arguments);
            timer = null;
        },delay)
    }
}
div.addEventListener('drag',throttle(function(e){
    console.log(e.offsetX,e.offsetY);
},100))
```

### 手写flat

> 实现原理：
>
> 第一个参数是数组，第二个是降维层级，
>
> 用for循环遍历这个数组，检测每一项
>
> 如果这项是不是数组则直接添加到`ret`结果数组里面
>
> 否则根据降维层级判断,默认是降一维层级，当递归降维不满足`ret>0`，说明已经达到dep降维层数了，其它情况即`ret.push(arr[i])`
>
> //原生的flat
> const arr1 = [1, 2, [3, 4]];
> arr1.flat(); 
> // [1, 2, 3, 4]
> const arr2 = [1, 2, [3, 4, [5, 6]]];
> arr2.flat();
> // [1, 2, 3, 4, [5, 6]]
> const arr3 = [1, 2, [3, 4, [5, 6]]];
> arr3.flat(2);
> // [1, 2, 3, 4, 5, 6]
> const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];
> arr4.flat(Infinity);
> // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

```javascript
/*手写flat*/
function flatDeep(arr,deep = 1){
    if(arr.length == 0) return arr;
    let result = [];
    for(let i=0;i<arr.length;i++){
        if(Array.isArray(arr[i])){
         deep>0?(result = result.concat(flatDeep(arr[i],deep-1))):(result.push(arr[i]))
        }else{
            result.push(arr[i]);
        }
    }
    return result;
}
```

### 手写深拷贝

```javascript
function deepClone(obj = {}){
    if(typeof obj != 'object' || obj == null){
        return obj;
    }
    let result;
    if(obj instanceof Array){
        result = [];
    }else{
        result = {};
    }
    for(let key in obj){
        if(obj.hasOwnProperty(key)){
            result[key] = deepClone(obj[key]);
        }
    }
    return result;
}
```

### 手写call

> 实现原理：
>
> 函数的原型方法call 第一个参数是传入的执行上下文，后面传入的都是参数，以逗号隔开
>
> 当传入的是null或undefined是执行上下文是指向`window`，否使为传入的对象，然后再传入的对象身上添加`fn`属性并把函数实例say函数赋值给fn，此时变成
>
> ```
> var obj = {name:'innerName',fn:function say(){console.log(this.name)}}`此时`context`就是obj对象啦，所有你执行`context.fn(...args)
> ```
>
> 其实就是`obj.fn(...args)`，`fn` 其值是 `function say（）{ console.log(this.name) }`,所以这个`this`就变成`obj`对象了
>
> 然后就是结果赋值，对象还原
>
> 返回结果

```javascript
Function.prototype.myCall = function(context){
    context =(context === null || context === undefined) ? window : context
    context.fn = this// 其实就等价于 obj.fn = function say(){} 当指向 context.fn 时，say里面的this 指向obj [关键]
    //obj 此时变成 var obj = {name:'innerName',fn:function say(){console.log(this.name)}}
    let args = [...arguments].slice(1) //截取第二个开始的所有参数
    let result= context.fn(...args)//把执行的结果赋予result变量
    delete context.fn //删除执行上下文上的属性 （还原）由var obj = {name:'innerName',fn:function say(){console.log(this.name)}}删除fn
    return result
}
var name = 'outerName'
var obj = {
    name:'innerName'
}
function say(){
    console.log(this.name)
}
say()//outerName     等价于  window.say    this指向window
say.myCall(obj)//innerName
```

### 手写bind

> bind 的手写实现，与其它两个区别是返回一个函数，并没返回函数执行的结果，并且受参形式不受限制
>
> 实现原理：
>
> 通过 `Object.create`方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`,通过 中介对象`o`来实现，来达到不影响传入的对象

```javascript
Function.prototype.myBind = function(context){
    context =(context === null || context === undefined) ? window : context
    let o = Object.create(context)
    o.fn = this
    let args = [...arguments].slice(1)
    let result= function(){   
       	 o.fn(...args)
    }
    return result
}
```

### 手写apply

> 同`myCall`实现原理大致相同，不同的是由于`call`和`apply`的传参方式不一样，
>
> 我们需要额外的对第二个参数做判断，`apply`受参形式是数组，且再第二个参数位置，
>
> 一：如果第二个参数存在，执行的时候就把第二个参数（数组形式）用扩展运算符打散后传入执行
>
> 二：如果第二个参数不存在，执行执行
>
> 其它就于`call`的实现一样

```javascript
Function.prototype.myApply = function(context){
    context =(context === null || context === undefined) ? window : context;
    context.fn = this;
    let result = arguments[1] ? context.fn(...arguments[1]) : context.fn()
    delete context.fn;
    return result;
}
```

### 手写promise.all

> const p1 = Promise.resolve(2);
>
> const p2 = Promise.resolve(Promise.resolve(3));
>
> const p3 = Promise.resolve(Promise.reject(4));
>
> const pAll = Promise.all([p1,p2,p3]);
>
> pAll.then(
>
> ​	values =>{
>
> ​		console.log('race onResolved',value);
>
> ​	},
>
> ​	reason =>{
>
> ​		console.log('race onRjected()',reason);
>
> ​	}
>
> )

```javascript
/* 
  Promise函数对象的all方法
  返回一个promise, 只有当所有proimse都成功时才成功, 否则只要有一个失败的就失败
  */
  Promise.all = function (arr) {
    // 用来保存所有成功value的数组
    const values = new Array(arr.length) 
    // 用来保存成功promise的数量
    let resolvedCount = 0
    // 返回一个新的promise
    return new Promise((resolve, reject) => {
      // 遍历promises获取每个promise的结果
      arr.forEach((p, index) => {
        Promise.resolve(p).then(
          value => {
            resolvedCount++ // 成功的数量加1
            // p成功, 将成功的vlaue保存vlaues
            // values.push(value)
            values[index] = value
            // 如果全部成功了, 将return的promise改变成功
            if (resolvedCount===promises.length) {
              resolve(values)
            }
          },
          reason => { // 只要一个失败了, return的promise就失败
            reject(reason)
          }
        )
      })
    })
  }

```

### 手写双飞翼布局

```javascript
<style>
#center {
    float: left;
    width: 100%;
    /*左栏上去到第一行*/
    height: 100px;
    background: blue;
}
#left {
    float: left;
    width: 180px;
    height: 100px;
    margin-left: -100%;
    background: #0c9;
}
#right {
    float: left;
    width: 200px;
    height: 100px;
    margin-left: -200px;
    background: #0c9;
}

/*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/
#inside {
    margin: 0 200px 0 180px;
    height: 100px;
}
</style>
<body>
    <div id="center">
        <div id="inside">middle</div>
    </div>
    <div id="left">left</div>
    <div id="right">right</div>
</body>
```

### 手写圣杯布局

```javascript
<style>
#bd{
    padding: 0 200px 0 180px;
    height: 100px;
}
#middle{
    float: left;
    width: 100%;
    height: 500px;
    background:blue;
}
#left{
    float:left;
    width:180px;
    height:500px;
    margin-left:-100%;
    background: #0c9;
    position: relative;
    left: -180px;
}
#right{
    float: left;
    width: 200px;
    height: 500px;
    margin-left: -200px;
    background: #0c9;
    position: relative;
    right: -200px;
}
</style>
<body>
    <div id="bd">
        <div id="middle">middle</div>
        <div id="left">left</div>
        <div id="right">right</div>
    </div>
</body>
```

### 快速排序

> ​	主要思想：假设以数组的最后一个数为中心，小于它的放在右边，大于它的放在左边，等于它的放中间，然后对于左边的元素选定最后一个为中心，右边的元素选定最后一个数为中心，进行同样的递归。
>
> ​	时间复杂度：O(nlogn)
>
> ​	不稳定算法

```javascript
var quickSort = function(arr) {
　　if (arr.length <= 1) { 
      return arr; 
  	}
　　var pivotIndex = Math.floor(arr.length / 2);
　　var pivot = arr.splice(pivotIndex, 1);
　　var left = [];
　　var right = [];
　　for (var i = 0; i < arr.length; i++){
　　　　if (arr[i] < pivot) {
 			left.push(arr[i]);
　　　　} else {
　　　　　　	right.push(arr[i]);
　　　　}
　　}
　　return quickSort(left).concat(pivot, quickSort(right));
};
```

### 堆排序

> ​	时间复杂度：O(nlogn)
>
> ​	不稳定算法
>
> ​	思想：构建一个大根堆，将大根堆的堆顶元素与堆低最后一个节点元素进行交换，此时堆的最后一个节点就是最大值，然后对剩余的n-1个节点构建大根堆，构建好了之后再交换堆顶元素与最后一个节点元素。以此循环往复。
>
> ​	构建大根堆：从下往上以此遍历二叉树，通过其子节点的（n-1）/2找到其父节点的位置，当父节点小于子节点时交换位置，依次循环。

### 归并排序

> ​	时间复杂度：O(nlogn)
>
> ​	稳定的算法
>
> ​	思想：
>
> ​		分解（Divide）：将n个元素分成个含n/2个元素的子序列。
> ​		解决（Conquer）：用合并排序法对两个子序列递归的排序。
> ​		合并（Combine）：合并两个已排序的子序列已得到排序结果。	

### 爬楼梯/跳台阶

```javascript
function jumpfloor(num){
    if(num === 1) return 1;
    if(num === 2) return 2;
    return jumpfloor(num-1)+jumpfloor(num-2);
}
```

​	牛客：https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&&tqId=11161&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking

​	leetcode：https://leetcode-cn.com/problems/climbing-stairs/

### 变态跳台阶

> f(n) = f(n-1)+f(n-2)+...+f(1)
>
> f(n-1)  = f(n-2)+...f(1)	
>
> f(n) = 2f(n-1)

```javascript
function jumpFloorII(number)
{
    if(number == 1) return 1;
    return jumpFloorII(number-1)*2;
}
```

​	牛客：https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&&tqId=11162&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking

### 反转链表

> 定义三个用于替换的变量cur、pre、next，cur用于存储当前节点，pre用于存储当前节点的前一个节点，next用于存储当前节点的下一个节点。

```javascript
function ReverseList(pHead)
{
    // write code here
    if(pHead == null || pHead.next == null){
        return pHead;
    }
    let cur = pHead;
    let pre = null;
    let next = null;
    while(cur){
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

​	leetcode：https://leetcode-cn.com/problems/reverse-linked-list-ii/

### *叉树先序遍历（递归）

```javascript
var preorderTraversal = function(root) {
    let arr = [];
    function getResult(root,arr){
        if(!root) return;
        arr.push(root.val);
        getResult(root.left,arr);
        getResult(root.right,arr);
    }
    getResult(root,arr);
    return arr;
};
```

​	leetcode：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

### *平衡二叉树



### *判断两个二叉树是否完全一致



### 从上到下打印一颗二叉树

​	牛客：

​	leetcode：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/

### 简单正则

> 输入：aaaa-aaa-bbb
> 输出：aaaaAaaBbb，
> 正则如何写

```javascript
let str = aaaa-aaa-bbb
str.replace(/\-\w/g,m=>m.slice(1).toUpperCase())
```

### 正则表达式匹配

```javascript

```

​	leetcode：https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/

### *旋转数组

```javascript
var minArray = function(numbers) {
  var left=0,right = numbers.length-1;
  while(left<right){
       var mid = Math.floor(left+(right-left)/2);
       if(numbers[mid]>numbers[right]){
           left = mid+1;
       }else if(numbers[mid]<numbers[right]){
           right = mid;
       }else{
           right--;
       }
  }
  return numbers[left];
};
```

​	leetcode：https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/

### *合并两个有序数组



### *二分查找

```javascript
function search(arr,data){
        var max = arr.length-1,  //最大值
            min = 0;  //最小值
        while(min<=max){
            var mid = Math.floor((max+min)/2); //中间值
            if(arr[mid]<data){
                min = mid+1;
            }else if(arr[mid]>data){
                max = mid-1;
            }else{
                return mid; 
            }
        }
        return false;   //没找到返回false
    }    
```

### 数组中重复的数字



### 和为S的两个数字

​	

### 数组中的逆序对

​	





