### 1、写一个继承

#### （1）ES5中的继承

##### 	构造函数继承

```JavaScript
function Person(){
    this.name="parent"
    this.arr = [1,2,3,4]
}
Person.prototype.say = function(){
    console.log('hhaha')
}
function Son(age){
   	Person.apply(this);
    this.age = age;
}
var s = new Son(21);
s.parent //"parent"
s.arr  //[1,2,3,4]
s.age  //21
s.say()  //undefined
```

##### 	原型链继承

```javascript
function Person(){
    this.name = “parent”
    this.arr = [1,2,3,4]
}
Person.prototype.say = function(){
    console.log("hahah")
}
function Son(21){
    this.age = age;
}
Son.prototype = new Person();
var s1 = new Son(21);
s1.arr   //[1,2,3,4]
s1.arr.push(5)
var s2 = new Son(21)
s2.arr  //[1,2,3,4,5]
```

##### 	构造函数+原型链继承

```javascript
function Person(){
    this.name = "parent"
    this.arr = [1,2,3,4]
}
Person.prototype.say = function(){
    console.log("hahah")
}
function Son(age){
    Person.call(this);
    this.age = age;
}
Son.prototype = new Person();
Son.prototype.Constructor = Son;
var s1 = new Son(23);
var S2 = new Son(25);
s1.arr.push(5);
s2.arr //[1,2,3,4]
```

#### （2）ES6中的继承

```javascript
class Person{
    Constructor(){
        this.name = "parent";
        this.arr = [1,2,3,4];
    }
    say(){
        console.log("hahha")
    }
}
class Son extends Person{
    Constructor(age){
        super();
        this.age = age;
    }
}
var s = new Son(); //均能正常继承
```

### 2、new一个对象的过程

1、创建一个空对象

```javascript
var obj = new Object（）；
```

2、改变函数this指向，让函数的this指针指向对象，并执行函数

```javascript
var result = Person.apply(this);
```

3、构造原型链，将对象的隐式原型赋值为函数的显示原型

```
obj.__proto__ = Person.prototype;
```

4、判断返回值类型，若返回值为值类型则直接返回这个值，若为引用类型则返回该引用类型的对象

### 3、this的指向

#### （1）如何改变this的指向

​	1、通过apply()和call()来改变

​	2、通过bind()改变

​	3、通过new来改变

​	4、通过return来改变

#### （2）如何判断this的指向

​	1、直接使用的函数指向全局window

​	2、普通函数的this指向调用他的对象或者指向作为构造函数创建的对象

​	3、箭头函数的this指向声明它的上下文即声明时的作用域中的this

​	4、return 一个函数中的this指向该函数对象

### 4、代码

```javascript
function Fater(name, age) { 	
	this.name = name; 
    return 'xxx' 
}
var f = new Father()
//问：f是什么？
```

​	f是father的一个实例，通过该实例可以向Father中传值并调用

### 5、this指向题

```javascript
var test = { 
	a: 40, 
    init: () => { 
    	console.log(this.a);
    	function go() { 
    	   this.a = 60; 	
           console.log(this.a); 
    	 }
    	go.prototype.a = 50;
    	return go; 
   } 
 };
var p = test.init(); 
p();
new (test.init())();
//undefined  this指向window，此时的window中还没有a
//60	this指向window，this.a=60把window中的a赋值为60，并打印一次
//60	this指向window，a = 60
//60	再赋值再打印
```

### 6、promise相关题

```javascript
const promise = new Promise((resolve, reject) => { 	
	console.log(1); 
	resolve(5); 
    console.log(2); 
}).then(val => { 
	console.log(val); 
}); 
promise.then(() => { 		
	console.log(3); 
}); 
console.log(4); 
setTimeout(function() {
	console.log(6); 
});
//1 2 4 5 3 6
```

### 7、事件循环机制（event-loop）

​	1、JS顺序执行全局同步代码，执行完毕后清空调用栈call satck

​	2、查看微队列，并将微队列中位于队首的微任务取出放入调用栈执行，执行完后再取再执行直到微队列为空。若在执行过程中又有新的微任务生成，则放入微队列队尾并在此周期内执行。

​	3、查看宏队列，将宏队列中位于队首的宏任务取出执行。

​	4、循环执行2-3步

### 8、宏任务、微任务

​	在宏队列中执行的任务叫做宏任务，一般包括setTimeout、setInterval、UI渲染等。

​	在微队列中执行的任务叫做微任务，一般包括promise、async/await、MutationObserver

​	同一轮执行的微任务总在宏任务之前执行。

### 9、代码题

输入：aaaa-bbb-ccc 输出：aaaaBbbCcc怎么写

```javascript
var str = "aaaa-bbb-ccc"
str.replace(/\-\w/g,m=>m.slice(1).toUpperCase())
```

### 10、强制缓存、协商缓存

##### （1）强制缓存

​	使用cache-control或Expires，目前cache-Control已经取代了Expires

​	过程：

​	浏览器第一次向服务器请求数据时，服务器在响应头中会给浏览器返回一个cache-control，里面保存着最长缓存的时间max-age，在此时间范围内，浏览器再次请求会直接返回缓存中的资源给浏览器。若缓存过期，浏览器会继续发起网络请求，服务返回资源并设置缓存时间。   

##### （2）协商缓存

​	使用Last-Motified/if-motified-since 或ETag/if-None-Match ,Etag的性能要优于Last-motified

​	过程：

​	浏览器第一次向服务器请求资源，服务器接收到请求在返回资源的同时给浏览器返回Last-motified，里面存储着资源标识符，浏览器接收到这个资源标识符后会将其保存，在下一次请求资源时在If-motified-since中携带这个资源标识符，服务器接收到这个资源标识符并于自身的进行比对，如果一样则返回304让浏览器使用本地的缓存资源，如果不一样则返回新的资源和新的资源标识符给浏览器。

> last-motified表示资源的最后生成时间，Etag是根据资源内容来计算得到的一个字符；last-motified只能精确到秒级，而Etag是一个资源的唯一标识字符串。一般情况下协商缓存会优先使用Etag，如果资源被重复生成但是内容不变的话，则Etag更精确。

##### （3）刷新对缓存的影响

1、正常刷新：对强制缓存和协商缓存都无效

2、F5或者点击刷新按钮：强制缓存失效，协商缓存有效

3、强制刷新ctrl+f5：强制缓存和协商缓存均失效

### 11、Vue的生命周期

Vue的生命周期主要分为三个阶段：初始化界面、更新显示、销毁Vue实例

(1)、初始化显示：beforeCreate()、Created()、beforeMount()、Mounted()

(2)、更新显示：beforeUpdate()、updated() 

(3) 、销毁Vue实例：beforeDestroy()、destroyed()

### 12、null和undefined的区别

undefined表示此处本该有值，但是还没有被定义，比如定义一个变量但是没有赋值。null表示此处为空不应该有值。原型链的最顶端就是null。typeof null的返回是object

### 13、JS执行上下文和作用域

​	<font color='red'>执行上下文就是当前JavaScript代码被解析和执行的时候所在环境的抽象概念</font>，JavaScript中执行的任何代码都在执行上下文中运行。它分为全局执行上下文和函数执行上下文。在执行上下文的创建阶段会做一下几件是：创建变量对象、创建作用域链、确定this的值。

​	作用域就是变量或函数的可访问范围，控制着这个变量或者函数的可访问行或者周期。ES6之前有全局作用域、函数作用域，在ES6中增加了一个局部作用域，全局作用域只要不被函数或代码块包裹的就是全局作用域，函数作用域就是函数体内的变量和参数，块级作用域就是像if或for循环等包裹的代码块中的作用域。

### 14、map和Object的区别

1、Object和Map都是hash结构的键值对集合，Map继承与Object。Object只能用字符串、数字等简单的数据类型不能是对象，Map的键可以是任意数据类型。

2、Map中的元素顺序遵循插入顺序，而Object中没有这一特征。

3、Map的键值存储的是这块内存的地址，所以可以解决同名碰撞的问题，而Object不行。

4、Map实现了迭代器，可用for....of遍历，而Object不行。

### 15、冒泡和捕获介绍一下

1、事件冒泡是由IE开发团队提出来的，即事件开始时由最具体的元素文档中嵌套最深的那个节点接收，然后逐级向上传播。

2、事件捕获是由网景公司提出，即由最上一级的节点先接收事件，然后向下传播到具体的节点。

3、事件冒泡可以用stopPropagation()来阻止。

### 17、闭包是什么，他的作用和应用场景，有什么缺陷？

当嵌套函数内部函数引用外部变量或对象时，就会产生闭包。

作用：可以用来封装函数，使得内部变量不会被外部函数访问，方便隐藏数据

缺点是：由于变量不会被及时释放，容易造成内存泄漏

### 18、function本身有哪些方法

1、bind()

2、apply()

3、call()

4、toString()

5、判断一个对象本身有哪些方法可以用hasOwnProperty()

### 19、Call()、apply()、bind()的区别

1、Call和apply都是调用另一个对象的方法，其中第一个参数代表的是另一个对象，后面的参数是传入的数据。不通点在于apply传入的数据是数组形式。

2、bind()方法会创建一个新的函数称为绑定函数，绑定函数会以创建它时传入的第一个参数作为this，第二个及以后的参数加上原函数本身的参数作为原函数的参数来调用。

3、bind是返回函数方便稍后调用，apply()和call()是立即调用。

### 20、ajax的实现原理，有什么方法？

```javascript
var x = new XMLHttpRequest();
x.open();
x.send();
x.onreadystatechange = function(){
    if(x.readyChange === 4){
        if(x.status>=200&&x.status<=300){
            console.log(x.resopnse);
        }
    }
}
```

### 21、ES6新增哪些方法

1、函数继承上的区别

2、作用域上的区别

3、新增Map函数

4、新增const、let定义变量的关键字

5、promise函数

6、箭头函数

7、数组中的展开运算符

### 22、let、const、var的区别

var：

1、有全局作用、函数作用域的概念

2、定义后不用初始化，默认值为undefined

3、同一作用域下允许重复声明

4、存在变量提升

5、全局作用域下用var声明会挂载到window下面

let：

1、增加了块级作用域的概念

2、不存在变量提升

3、存在暂时性死区，即变量没有声明前该变量是不可用的，在语法上叫做暂时性死区

4、同一作用域下不予许重复声明

const：

在let的基础上增加了初始化必须赋值、常量值不可以改变。

### 23、箭头函数和普通函数的区别

1、箭头函数都是匿名函数，而普通函数既可以是匿名函数又可以是具名函数

2、普通函数在定义后会有一个arguments的对象，用来存储参数，而匿名函数没有

3、箭头函数不可以当做构造函数，普通函数可以用于构造函数，以此创建实例。

4、箭头函数本身不创建this，而是通过捕获其声明时的作用域中的this作为自己的this。普通函数的this指向引用它的对象或者指向构造函数创建它的实例。

### 24、处理异步的几种方法

1、回调函数

2、promise

3、async/await

4、发布和订阅

5、事件监听

### 25、盒模型

理解：盒模型就是一个盒子，他可以封装它周围的html元素。它包含边距margin、边框border、填充padding和实际内容content。

offsetwidth：（边框宽度+填充宽度+实际内容宽度），无边距

### 26、BFC块级上下文

理解：BFC即块级上下文，它是一个独立的块级渲染容器，拥有自己的渲染规则，不受外部影响也不影响外部

形成条件：

​	1、float不是none

​	2、overflow不是visible

​	3、position不是static或relative

​	4、display是flex、inline-block等

作用：

​	1、可以阻止margin重叠

​	2、可以包含浮动元素

​	3、自适应两栏布局

​	4、可以阻止元素被浮动元素覆盖	

### 27、input的type标签列举

1、password

2、text

3、reset

4、submit

5、button

### 28、DOM本身API的列举

1、createElement

2、createTextNode

3、setAttribute

4、getAttribute

5、appendChild

6、getElementById

7、getElementByTagName

8、parentNode

### 29、隐藏页面元素的方法

1、opacity:0

2、visibility:hidden

3、display:none

4、使用绝对定位将元素移除可视区域

### 30、CSS具有的继承属性

1、所有元素都具有的继承属性

​	元素可见性：visibility、opacity

​	光标属性：cursor

2、内联元素可以继承的属性

​	字体属性

​	除text-indent、text-align之外的文本系列属性

3、块级元素可以继承的属性

​	text-indent

​	text-align

### 31、清楚浮动的方法

1、给父级元素添加overflow方法，触发BFC

2、在最后一个浮动标签后，新添加一个标签，给其设置clear:both

3、使用after的伪元素

4、使用before和after双伪元素

### 32、响应式布局的实现方法

1、media-query:根据不同的屏幕宽度设置根元素font-size

2、rem:基于根元素的相对单位

### 33、Vue中双向绑定的原理

​	原理：通过数据的劫持监听结合订阅者-发布者模式实现的，在Observer中使用defineProperty来实现对数据的追踪，在defineProperty中有get()和set()两个函数，当外界通过订阅者Watcher读取数据时，会触发get()函数，将数据对应的依赖Watcher添加到Dep中。当数据发生了变化时，会触发set函数，向Dep中对应的Watcher发送通知。Watcher收到通知后会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数。

### 34、v-if和v-for的区别

v-if和v-show都是用来控制元素的显示。

1、v-if：v-if每次都会创建或删除元素，切换时具有较高的性能消耗，如果需要显示的元素不会被经常操作建议用v-if。

2、v-show：不会重新进行DOM的删除和创建操作，只是切换了元素的dispaly:none样式。但是v-show就有较高的初始化渲染消耗，所以如果切换比较频繁的话建议用v-show。

### 35、跨域的几种方法

1、jsonp

原理：利用script标签天生具有的跨域能力

2、CORS

原理：通过在响应头中设置Access-Control-Allow-Origin告诉浏览器允许跨域，浏览器收到响应后就会放行

### 36、http请求有哪些，option的应用场景，复杂请求和简单请求怎样区分

1、get

2、post

3、head

4、put

5、delete

6、option

7、connect

8、trace

​	option：通常用于预检请求，即在跨域访问之前先给服务器发送一次请求，让服务器返回允许的请求方法。

复杂请求和简单请求：

​	简单请求浏览器不会预检，而非简单请求会预检。同时满足下列三大条件，就属于简单请求，否则属于非简单请求：
​	1.请求方式只能是：GET、POST、HEAD
​	2.HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID。
​	3.Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain。

### 37、前端性能优化的方法

##### 加载资源优化

1、减少资源体积：如压缩代码（webpack中的生产者环境）

2、减少访问次数：如合并代码、使用缓存等方法

3、使用更快的网络CDN，即使用全局负载技术将用户的访问指向最近的正常工作的缓存服务器上，由缓存服务器直接响应用户的请求。

##### 渲染优化

1、将CSS放在head中，js放在body的最下边。如果不放在最下边可能会影响首屏的渲染，截断首屏的内容使其只显示上一部分内容。

2、使用DOMContentLoader事件触发（DOMContentLoaded事件在页面文档加载解析完毕之后马上执行，而不会等待图片文件和子框架页面的加载；load事件会在页面所有资源被加载进来之后才会触发load事件。load时间在DOMContentLoaded事件触发之后。）

3、使用懒加载即按需加载

4、将频繁的DOM操作合并后在一起插入DOM

5、对DOM查询进行缓存

6、使用SSR（server  side render）:简单理解就是将组件或页面通过服务器生成HTML字符串，再发送到浏览器，客户端拿到后可以直接呈现给用户HTML中的内容，而不需要为了生成DOM内容自己去跑一遍js。

参考：https://www.cnblogs.com/shidengyun/p/5123377.html

##### 体验优化：

1、防抖

2、节流

### 38、http1.0，1.1，2.0，3.0的区别

##### http1.0:

1、请求和响应支持http头，响应含状态行，增加了状态码

2、支持HEAD、POST方法

3、支持除HTML文件以外的其他类型文件

4、非持久性连接，客户端需要为每一个待请求的对象建立并维护一个新的连接

##### http1.1:

1、支持长连接

2、在http1.0的基础上引入了更多的缓存策略

3、在错误管理中增加了响应错误的状态码

4、在请求消息中增加了范围设置，优化了带宽

5、增加了host头处理，可传递主机名

##### http2.0:

1、多路复用

2、头部压缩

3、使用二进制格式解析

4、服务端推送

##### http3.0:

1、基于UDP的多路复用，可在切换网络时保持连接

2、0 RTT 建联

3、向前纠错机制

4、请求报文加密

### 39、浏览器渲染的过程

1、浏览器获取到html文档解析成DOM树，并在生成的最开始阶段发起CSS、图片、JS的请求。

2、处理CSS标记，当CSS文件下载完成后开始CSSOM（生成层叠样式表模型）。

3、将DOM树和CSSOM合并生成渲染树render.

4、layout，根据渲染树计算出每个节点在屏幕中的位置，这一步称为layout

5、painting ，将渲染树的各个节点绘制到屏幕上。

如果JS修改了DOM或者CSS属性，那么1、2、3步会Update