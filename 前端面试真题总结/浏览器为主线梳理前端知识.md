### 1、浏览器进程

​	当前的Chrome浏览器打开一个页面，至少会启动四个进程：浏览器进程、网络进程、渲染进程和GPU进程。另外浏览器通常还会有插件进程。其各进程的作用如下：

（1）**浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

（2）**渲染进程（一个或多个）**：主要负责把从网络上下载下来的HTML、JavaScript、CSS、图片等资源解析为可显示和交互的页面。由于这些资源都是从网上下载下来的，可能会存在一些恶意代码利用浏览器漏洞对浏览器进行攻击，所有渲染进程里面的代码是不被信任的，Chrome中让渲染进程运行在安全沙箱。

​	通常情况下，打开一个新的页面会有一个单独的渲染进程，但是如果从A页面打开B页面，且A和B页面属于同一个站点的话，那么B页面会复用A页面的渲染进程。

（3）**网络进程**：主要负责网络资源的加载，为渲染进程和浏览器进程提供下载功能。

（4）**GPU进程：**使用的初衷是为了实现3D的CSS效果，但后来网页、Chrome的UI界面都选择采用GPU来绘制。

（5）**插件进程（一个或多个）**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。为防止恶意插件，通常插件进程也是运行在安全沙箱里。

### 2、强制缓存

​	使用cache-control/Expires，目前cache-Control已经取代了Expires

​	**Expires**

​	Expires 是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。这个时间代表的该资源的失效时间，如果在该时间之前请求的话，则都是从缓存里面读取的。但是使用该规范时，可能会有一个缺点就是当服务器的时间和客户端的时间不一样的情况下，会导致缓存失效。

​	**Cache-Control**

​	**Cache-Control** 是http1.1的规范，它是利用该字段max-age值进行判断的。该值是一个相对时间，比如 	**Cache-Control: max-age=3600,** 代表该资源的有效期是3600秒。除了该字段外，我们还有如下字段可以设置：

​	**no-cache:** 需要进行协商缓存，发送请求到服务器确认是否使用缓存。

​	**no-store：**禁止使用缓存，每一次都要重新请求数据。

​	**public：**可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。

​	**private：**只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。

Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。

​	过程如下：

​	浏览器第一次向服务器请求数据时，服务器在响应头中会给浏览器返回一个cache-control，里面保存着最长缓存的时间max-age，在此时间范围内，浏览器再次请求会直接返回缓存中的资源给浏览器。若缓存过期，浏览器会继续发起网络请求，服务器重新返回资源并设置时间。

### 3、协商缓存

​	使用Last-Motified/if-motified-since 或ETag/if-None-Match ,Etag的性能要优于Last-motified

#### （1）Last-Motified/if-motified-since

​	浏览器第一次发出请求一个资源的时候，服务器会返回一个last-Modify到hearer中. Last-Modify 含义是最后的修改时间。当浏览器再次请求的时候，request的请求头会加上 if-Modify-Since，该值为缓存之前返回的 Last-Modify. 服务器收到if-Modify-Since后，根据资源的最后修改时间(last-Modify)和该值(if-Modify-Since)进行比较，如果相等的话，则命中缓存，返回304，否则, 如果 Last-Modify > if-Modify-Since, 则会给出200响应，并且更新Last-Modify为新的值。

#### （2）ETag/if-None-Match

​	ETag的原理和上面的last-modified是类似的。ETag则是对当前请求的资源做一个唯一的标识。该标识可以是一个字符串，文件的size,hash等。只要能够合理标识资源的唯一性并能验证是否修改过就可以了。ETag在服务器响应请求的时候，返回当前资源的唯一标识(它是由服务器生成的)。但是只要资源有变化，ETag会重新生成的。浏览器再下一次加载的时候会向服务器发送请求，会将上一次返回的ETag值放到request header 里的 if-None-Match里面去，服务器端只要比较客户端传来的if-None-Match值是否和自己服务器上的ETag是否一致，如果一致说明资源未修改过，因此返回304，如果不一致，说明修改过，因此返回200。并且把新的Etag赋值给if-None-Match来更新该值。

#### 区别：

> last-motified表示资源的最后生成时间，Etag是根据资源内容来计算得到的一个字符；last-motified只能精确到秒级，而Etag是一个资源的唯一标识字符串。一般情况下协商缓存会优先使用Etag，如果资源被重复生成但是内容不变的话，则Etag更精确。

1. 在精度上，ETag要优先于 last-modified。
2. 在性能上，Etag要逊于Last-Modified，Last-Modified需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
3. 在优先级上，服务器校验优先考虑Etag。

### 4、HTTP请求及服务端响应中的一些字段

#### （1）HTTP请求数据格式

![](F:\笔记\JavaScript-Notes\面试真题\img\Snipaste_2021-02-02_20-02-48.png)

##### 	请求行：

​		1、请求方法，如get、post等

​		2、请求的URI

​		3、Http协议版本

##### 	请求头：

​		1、Host：主机地址

​		2、Cache-Control：缓存控制

​		3、Cookie：

##### 	请求体：

#### （2）服务端响应数据格式

![](.\img\Snipaste_2021-02-02_20-00-16.png)

##### 	响应行：

​		1、Http协议版本

​		2、状态码

##### 	响应头：

​		1、Content-type：text/html(响应体是html文件) application/octet-stream(响应体是字节流类型，通常会被浏览器当做下载类型处理)  。 它主要是告诉浏览器响应体的类型，可能是html、下载类型等。

​		2、缓存机制：Last-Motified/Etag

​		3、Location：浏览器需要重定向的主机地址

##### 	响应体：

​		1、html

​		2、下载类型

### 5、在浏览器中输入一个URL地址，到显示的过程

##### 	1、生成并传递url

​		浏览器进程检查url，组装协议，构成完整的url，浏览器进程通过进程间通信（IPC）把url请求发送给网络进程。

##### 	2、URL请求过程

​		（1）查找本地缓存

​			网络进程在发起网络请求之前，会先查找本地是否有缓存资源。如果有缓存资源且可用则直接返回资源给浏览器进程。如果没有或者缓存资源过时则直接进入网络请求流程。

​		（2）DNS域名解析，获取域名服务器的IP地址。

​		（3）TCP连接

​			利用IP地址和服务器建立TCP连接。

​		（4）发送Http请求

​			建立好连接后，浏览器会构建请求报文并发送给请求信息。

##### 	3、服务器处理并返回http报文

​		（1）重定向：如果需要重定向，会在响应报文的状态行中说明。浏览器在收到响应报文后，网络进程开始解析响应头，如果发现状态码是301或302就说明浏览器还需要重定向到其他的URL。会发起新的请求。

​		（2）响应数据类型处理：浏览器会判断Content-type里面是什么数据类型，如果是下载数据类型就会被提交给浏览器的下载管理器。

##### 	4、浏览器解析并渲染页面

​		（1）准备渲染进程

​		通常情况下，打开一个新的页面会有一个单独的渲染进程，但是如果从A页面打开B页面，且A和B页面属于同一个站点的话，那么B页面会复用A页面的渲染进程。

​		（2）提交文档

​		渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“**管道**”。等文档数据传输完成之后，渲染进程会返回“**确认提交**”的消息给浏览器进程。浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

​		（3）渲染阶段

​		一旦文档被提交，渲染进程便开始页面解析和子资源加载了。

##### 	5、连接结束

### 6、浏览器渲染页面的过程

​	1、浏览器将获取的HTML文档解析成DOM树，并在生成的最开始阶段并行的发起css、图片、js的请求。

​	2、处理CSS标记，当CSS文件下载完成后就开始构造层叠样式表模型CSSOM(CSS Object Model)。

​	3、将DOM和CSSOM合并为渲染树(rendering tree)，代表一系列将被渲染的对象。

​	4、浏览器根据渲染树计算出每个节点在屏幕中的位置，称之为Layout。

​	5、将渲染树的各个节点绘制到屏幕上，这一步被称为绘制painting。

#### 7、重排/回流、重绘

##### 	重排/回流：

​		当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流/重排(reflow)。

##### 	重绘： 

​		当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。

​	回流必将引起重绘，而重绘不一定会引起回流。



